---
title: "가정용 도서 관리 시스템 (2) - 도서 검색 API 알아보기"
categories: Home_Lib
---

오늘은 이번 프로젝트에서 사용할 **NAVER 책 검색 API**에 대해서 알아보도록 하겠습니다!

# STEP 1 : 오픈 API 이용 신청

오픈 API를 사용하기 전에는 이용 신청을 해야합니다! 신청하는 방법은 각 API의 Documents에 잘 설명되어 있습니다. 네이버의 경우 다음의 링크에서 확인하실 수 있습니다! ([NAVER API 공통 가이드](https://developers.naver.com/docs/common/openapiguide/appregister.md#%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%93%B1%EB%A1%9D))

Documents에 워낙 설명이 잘 되어 있어서 이용 신청하는 과정은 적지 않도록 하겠습니다! 바로 다음 단계로 바로 넘어가서 API를 호출하는 방법을 알아보겠습니다!

# STEP 2 : 파이썬 API 호출 예제 이해하기

다음의 링크에서 NAVER 블로그 검색 API를 다양한 언어로 호출하는 예제를 찾아볼 수 있습니다! ([NAVER 블로그 검색 Document](https://developers.naver.com/docs/serviceapi/search/blog/blog.md#%EB%B8%94%EB%A1%9C%EA%B7%B8)) 

검색 API는 호출방법이 모두 동일하여 블로그 검색만 대표로 나와있습니다. 그래서 이 블로그 예제를 한 줄 한 줄 이해해보려고 합니다!

다음은 네이버가 제공한 Python으로 블로그 검색 API를 호출하는 예제 코드입니다!

```python
import os
import sys
import urllib.request
client_id = "YOUR_CLIENT_ID"
client_secret = "YOUR_CLIENT_SECRET"
encText = urllib.parse.quote("검색할 단어")
url = "https://openapi.naver.com/v1/search/blog?query=" + encText # json 결과
# url = "https://openapi.naver.com/v1/search/blog.xml?query=" + encText # xml 결과
request = urllib.request.Request(url)
request.add_header("X-Naver-Client-Id",client_id)
request.add_header("X-Naver-Client-Secret",client_secret)
response = urllib.request.urlopen(request)
rescode = response.getcode()
if(rescode==200):
    response_body = response.read()
    print(response_body.decode('utf-8'))
else:
    print("Error Code:" + rescode)
```

## 코드 들여다보기

### 1~3번째 줄

```python
import os
import sys
import urllib.request
```

필요한 모듈을 import하고 있습니다. **os** 모듈과 **sys** 모듈은 이 코드에서는 안 쓰고 있는 것 같습니다..! 왜 import하는지 아시는 분들은 comment 부탁드립니다! 중요한 것은 세번째, **urllib**패키지의 **request** 라이브러리입니다! urllib은 URL 작업을 위한 모듈을 모은 패키지입니다! 우리가 사용할 모듈은 **urllib.request**와 **urllib.parse**입니다. request모듈은 URL을 열기 위한 라이브러리이고, parse모듈은 URL을 파싱하는 모듈입니다. 자세한 사용은 아래 줄을 더 살펴보면서 알아봅시다.

### 4~5번째 줄

```python
client_id = "YOUR_CLIENT_ID"
client_secret = "YOUR_CLIENT_SECRET"
```

4~5번째 줄입니다. 편의를 위해 **Client ID**와 **Client Secret**을 변수해 저장하고 있습니다. 오픈 API 이용 신청을 하면서 어플리케이션을 등록하면 Client ID와 Client Secret값을 발급받는데, 이는 API를 호출한 자가 인증된 사용자인지 확인하는 수단입니다. API를 호출할 때, **HTTP Header**에 이 두가지를 포함해서 전송해야 합니다.

### 6~8번째 줄

```python
encText = urllib.parse.quote("검색할 단어")
url = "https://openapi.naver.com/v1/search/blog?query=" + encText # json 결과
# url = "https://openapi.naver.com/v1/search/blog.xml?query=" + encText # xml 결과
```

6번째 줄에서는 **parse**모듈의 **quote** 함수를 사용하고 있습니다. quote 함수는 특수 문자와 비 ASCII 텍스트를 URL 요소로 안전하게 사용할 수 있도록 %xx 이스케이프로 변환합니다. 예를 들어, "안녕하세요"는 '%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94'로 변환됩니다. 한글은 비 ASCII 텍스트이기 떄문입니다.

```python
>>> import urllib
>>> urllib.parse.quote("안녕하세요")
'%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94'
```

7~8번째 줄은 API에 HTTP 요청을 보내기 위한 URL을 문자열로 변수에 저장하고 있습니다. 왜 저런 형식의 url이 나오는지 알아봅시다!

![블로그 검색 API 기본 정보](/images/home_lib/2/blog_api.png)

먼저, 위의 이미지처럼 **Document**에서 요청 URL을 확인합니다. 예제에서는 json 결과를 받기 위한 url을 사용했습니다. 그리고 주석으로 xml결과를 받기 위한 url도 적어두었습니다!

그리고 "?" 뒤로 query="검색할 단어"라는 **Query String**이 오고 있습니다. Query String이란 파라미터를 전달하는 방법으로 "?"를 기준으로 구분됩니다! field=key의 형식으로 전달되고 여러가지 파라미터를 전달할 때는 "&"을 사용하여 전달합니다. 예를 들어, **https://example.com?field1=key1&field2=key2**라는 url은 HTTPS 프로토콜로 example.com이라는 주소에 field1, field2라는 변수에 각각 key1, key2를 전달합니다.

![블로그 검색 API 변수 정보](/images/home_lib/2/blog_query.png)

Document를 참고하면 요청 변수를 확인할 수 있습니다. query라는 변수는 "검색하고자 하는 문자열"이니 완성된 url은 "검색할 단어"를 검색한 결과를 요청하는 주소입니다. 예시로 "Python"이라고 검색한 결과 150개를 xml로 요청하고 싶다면 url은 **"https://openapi.naver.com/v1/search/blog.xml?query=Python&display=150"**가 되겠죠! 원하는대로 url을 구성했으니 다음으로 넘어갑시다!

### 9~11번째 줄

```python 
request = urllib.request.Request(url)
request.add_header("X-Naver-Client-Id",client_id)
request.add_header("X-Naver-Client-Secret",client_secret)
```

9번째 줄에서는 request 모듈에 있는 **Request** 클래스를 이용해 request라는 객체를 만들고 있습니다. Request 클래스는 URL요청을 추상화해둔 클래스로서, 생성자에 url주소를 전달해주어야 합니다. 지금의 경우는 위에서 만들어둔 url을 전달했습니다.

10~11번째 줄에서는 HTTP 요청에 **Header**을 추가하고 있습니다. 위에서 언급했듯이 사용자 인증을 하기 위해 **Client ID**와 **Client Secret**을 헤더에 추가해야 합니다. 각각 **"X-Naver-Client-Id"**와 **"X-Naver-Client-Secret"**라는 Header로 추가하면 됩니다.

또한 9~11번째 줄은 다음과 같이 한 줄에 적을 수 있습니다.

```python
request = urllib.request.Request(url = url, headers = {"X-Naver-Client-Id" : client_id, "X-Naver-Client-Secret" : client_secret})
```

### 12번째 줄

```python
response = urllib.request.urlopen(request)
```

12번째 줄에서 API를 호출합니다. request 모듈에 정의된 **urlopen** 함수는 문자열 혹은 Request 객체로 url을 전달해주면 됩니다! 지금의 경우에는 Header을 추가한 Request 객체를 전달했습니다. HTTP, HTTPS URL의 경우 urlopen 함수는 **http.client.HTTPResponse** 객체를 반환합니다. 지금은 반환된 HTTPResponse 객체를 response라는 변수에 저장했습니다.

### 13번째 줄

```python
rescode = response.getcode()
if(rescode==200):
    response_body = response.read()
    print(response_body.decode('utf-8'))
else:
    print("Error Code:" + rescode)
```

HTTPResponse 객체의 **getcode** 메소드를 이용해 HTTP 상태 코드를 반환받아 rescode라는 변수에 저장합니다. 상태 코드 200은 성공적인 요청을 의미합니다. 그래서 if-else 구문을 이용해 상태 코드 200일때는 응답 결과를 출력하고, 그 외에 경우에는 Error Code를 출력합니다.

상태 코드가 200일 때는 HTTPResponse 객체의 **read** 메소드를 이용해 응답 Body를 읽어들이고 있습니다. 이때 반환값은 바이트이므로 **decode** 메소드를 사용해 **UTF-8**로 디코딩합니다.

## 정리

호출하는 과정은 간단합니다.

1. 필요한 정보를 Query String으로 조합하여 URL을 구성합니다.
2. Client ID와 Client Secret을 HTTP Header에 추가합니다.
3. API를 호출하고 응답을 받습니다.

조금 더 자세하게 하자면

1. urllib.parse.quote() 함수를 이용하여 Query String에 전달할 Key를 변환합니다.
2. API 요청 주소 뒤에 "?"를 더하고, 그 뒤에 Query String을 작성합니다. 전달할 파라미터가 여러개라면 "&"로 연결합니다.
3. 만들어 낸 URL로 urllib.request.Request 객체를 생성합니다.
4. 생성된 객체에 Client ID와 Client Secret을 Header로 추가합니다.
5. urllib.request.urlopen() 함수로 API를 호출합니다. 이때, 응답이 http.client.HTTPResponse 객체로 반환합니다
6. HTTPResponse 객체의 getcode() 메소드로 요청이 성공적인지 확인합니다.
7. 요청이 성공적이라면 read() 메소드로 요청 Body를 읽어들이고 decode 메소드로 디코딩합니다.

이해한 호출 과정을 기반으로 직접 도서를 검색해보도록 합시다!

# STEP 3 : 직접 도서 검색해보기

네이버가 제시한 예시는 블로그 검색 API입니다. 책 검색 API의 Document를 참고하면서 직접 책을 검색하는 코드를 작성해봅시다.

먼저 요청 URL을 확인해봅시다.

![책 검색 API 기본 정보](/images/home_lib/2/book_api.png)

기본 검색과 상세 검색이 있습니다. 오늘은 기본 검색만 사용해보도록 하겠습니다.

```python
# File name : book_search.py
# Author : Lee Junhee
# Last Update : 2020-04-13
# Purpose : Book Search using Naver Search Open API

from urllib import parse, request

client_id = MY_CLIENT_ID
client_secret = MY_CLIENT_SECRET

def search_book(search_text, output = "json"):
    
    if output != "json" and output != "xml":
        raise Exception("올바른 출력 형식이 아닙니다.")    

    query_string = parse.quote(search_text)
    url = "https://openapi.naver.com/v1/search/book." + output + "?query=" + query_string

    res = request.urlopen(request.Request(url = url, 
        headers = {
            "X-Naver-Client-Id" : client_id,
            "X-Naver-Client-Secret" : client_secret}))

    if res.getcode() == 200:
        return res.read().decode("utf-8")
    else:
        return res.getcode()
```

## 코드 들여다보기

제가 작성한 코드도 한 번 이해해보도록 합시다!

### 6번째 줄

```python
from urllib import parse, request
```

urllib 패키지의 parse 모듈과 request 모듈을 import합니다.

### 8~9번째 줄

```python
client_id = MY_CLIENT_ID
client_secret = MY_CLIENT_SECRET
```

편의를 위해 Client ID와 Client Secret을 변수에 저장했습니다.

### 11번째 줄
```python
def search_book(search_text, output = "json"):
```

검색할 텍스트와 출력 형태를 파라미터로 하는 search_book 함수를 정의합니다. 출력형태의 기본 값은 "json" 입니다.

### 13~14번째 줄
```python
    if output != "json" and output != "xml":
        raise Exception("올바른 출력 형식이 아닙니다.")    
```

전달 된 출력 형식이 "json"또는 "xml"이 아니라면 "올바른 출력 형식이 아닙니다."라는 오류를 발생시킵니다.

### 16~17번째 줄
```python
    query_string = parse.quote(search_text)
    url = "https://openapi.naver.com/v1/search/book." + output + "?query=" + query_string
```

검색할 텍스트를 파싱하여 query_string 변수에 저장해둡니다. 그리고 URL을 조합합니다. 이때, 두 요청 URL에서 "book.json", "book.xml"에만 차이가 있다는 점을 이용합니다.

### 19~22번째 줄
```python
    res = request.urlopen(request.Request(url = url, 
        headers = {
            "X-Naver-Client-Id" : client_id,
            "X-Naver-Client-Secret" : client_secret}))
```

조합한 URL과 Client Id와 Client Secret를 헤더로 추가하여 Request 객체를 만듭니다. 그리고 이를 별도로 저장하지 않고 바로 urlopen 함수에 인자로 전달하여 API를 호출합니다.

### 24~27번째 줄
```python
    if res.getcode() == 200:
        return res.read().decode("utf-8")
    else:
        return res.getcode()
```

HTTP 상태 코드를 확인하여 요청이 성공했을 때(200), 응답의 Body를 UTF-8로 디코딩하여 반환합니다. 그 외에 경우(실패)에는 상태코드를 반환합니다.

## 사용해보기

지금 눈 앞에 보이는 동역학 책의 ISBN을 검색해보겠습니다.

```
>>> from book_search import *
>>> search_book("9791132100997")
'{\n"lastBuildDate": "Tue, 13 Apr 2021 22:08:05 +0900",\n"total": 1,\n"start": 1,\n"display": 1,\n"items": [\n{\n"title": "동역학 (공학도를 위한)",\n"link": "http://book.naver.com/bookdb/book_detail.php?bid=11761324",\n"image": "https://bookthumb-phinf.pstatic.net/cover/117/613/11761324.jpg?type=m1&udate=20170313",\n"author": "Ferdinand P. Beer",\n"price": "37000",\n"discount": "",\n"publisher": "경문사",\n"pubdate": "20170110",\n"isbn": "1132100992 <b>9791132100997</b>",\n"description": "▶ 이 책은 동역학을 다룬 이론서입니다. 동역학의 기초적이고 전반적인 내용을 학습할 수 있도록 구성했습니다."\n\n}\n]\n}\n'
>>> search_book("9791132100997", output = 'xml')
'<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"><channel><title>Naver Open API - book ::\'9791132100997\'</title><link>https://search.naver.com</link><description>Naver Search Result</description><lastBuildDate>Tue, 13 Apr 2021 22:08:25 +0900</lastBuildDate><total>1</total><start>1</start><display>1</display><item><title>동역학 (공학도를 위한)</title><link>http://book.naver.com/bookdb/book_detail.php?bid=11761324</link><image>https://bookthumb-phinf.pstatic.net/cover/117/613/11761324.jpg?type=m1&amp;udate=20170313</image><author>Ferdinand P. Beer</author><price>37000</price><discount></discount><publisher>경문사</publisher><pubdate>20170110</pubdate><isbn>1132100992 &lt;b&gt;9791132100997&lt;/b&gt;</isbn><description>▶ 이 책은 동역학을 다룬 이론서입니다. 동역학의 기초적이고 전반적인 내용을 학습 
할 수 있도록 구성했습니다.</description></item></channel></rss>'
```

보시다시피, 쉽게 알아보기 힘듭니다. 그렇기 때문에, API가 반환한 데이터를 파싱하는 과정이 필요합니다.

# STEP 4 : JSON, XML 파싱하기

반환받은 데이터를 파싱해보록 합시다! JSON과 XML을 파싱하는 방법은 서로 다르며, 알기로는 JSON이 좀 더 흔한 형태인걸로 알고 있습니다!! JSON 파싱부터 알아봅시다!

## JSON 파싱

JSON 파싱을 위해서는 json 모듈을 이용하면 됩니다! 지금과 같이 JSON 문자열을 파싱해야하는 경우, **json.loads** 함수를 사용하면 됩니다. 이 함수를 이용하면 다음의 표대로 파이썬 객체로 변환됩니다. ([직접 확인하기](https://docs.python.org/3/library/json.html#json-to-py-table))

|JSON|Python|
|:--:|:----:|
|object|dict|
|array|list|
|string|str|
|number (int)|int|
|number (real)|float|
|true|True|
|false|False|
|null|None|

**CODE**
```python
# File name : json_parse.py
# Author : Lee Junhee
# Last Update : 2020-04-13
# Purpose : Parse JSON string and display it

import json
from book_search import *

search_text = "9791132100997"
result_dict = json.loads(search_book(search_text))

result_text = '''검색어 : {}
검색 시간  : {}
검색 결과 개수 : {}'''

item_text ='''검색 번호 : {}
책 제목 : {}
저자 : {}
정가 : {}
출판사 : {}
ISBN : {}
출간일 : {}'''

print(result_text.format(search_text, result_dict['lastBuildDate'], result_dict['display']))
for x in range(len(result_dict['items'])):
    i = result_dict['items'][x]
    print("")
    print(item_text.format(x+1, i['title'], i['author'], 
    i['price'], i['publisher'], i['isbn'], i['pubdate']))
```

**OUTPUT**
```
검색어 : 9791132100997
검색 시간  : Fri, 16 Apr 2021 00:17:25 +0900
검색 결과 개수 : 1

검색 번호 : 1
책 제목 : 동역학 (공학도를 위한)
저자 : Ferdinand P. Beer
정가 : 37000
출판사 : 경문사
ISBN : 1132100992 <b>9791132100997</b>
출간일 : 20170110
```

Document를 확인하면 각 변수가 무엇을 의미하는 지 알 수 있습니다([책 검색 API Document](https://developers.naver.com/docs/serviceapi/search/book/book.md#%EC%B1%85)). 책의 대한 정보는 **items**라는 속성에 담겨있습니다. 실제 작품을 만들 때는 필요한 Document에 제시된 key로 접근하여 정보를 얻어내면 되겠습니다.

## XML 파싱

XML파싱은 JSON 파싱보다는 조금 더 복잡합니다. XML 파싱을 위해서는 **xml.etree.ElementTree** (이하 ET) 모듈을 사용하면 됩니다. 지금과 같이 XML 문자열을 파싱해야 하는 경우, **ET.fromstring** 함수를 사용하면 됩니다. 딕셔너리로 변환되는 JSON과는 다르게, XML문서는 **Element**라는 객체로 변환합니다. 이 Element 객체를 이용해서, ET 모듈은 XML 문서를 트리로 표현합니다. Element는 트리에서 개별적인 노드이고, XML파일의 각 태그입니다. ET.fromstring 함수에서 반환되는 것은 최상위 노드(root node입니다.)

JSON과 마찬가지로, Document에서 태그의 이름을 확인하여 접근하면 됩니다. 이때 Element 객체의 **find**, **findall** 메소드를 사용합니다. find 메소드는 태그의 이름을 전달받아 첫번째 해당 태그를 가진 Element 객체를 반환합니다. findall 메소드는 find 메소드와 비슷하지만, 해당 태그를 가진 Element 객체를 전부 찾아 리스트로 반환합니다. 시작 태그와 종료 태그 사이에 있는 텍스트를 추출하기 위해서는 **text** 속성을 사용하면 됩니다.

**CODE**
```python
# File name : xml_parse.py
# Author : Lee Junhee
# Last Update : 2020-04-13
# Purpose : Parse XML string and display it

import xml.etree.ElementTree as ET
from book_search import *

search_text = "9791132100997"
result = ET.fromstring(search_book(search_text, 'xml'))[0]

result_text = '''검색어 : {}
검색 시간  : {}
검색 결과 개수 : {}'''

item_text ='''검색 번호 : {}
책 제목 : {}
저자 : {}
정가 : {}
출판사 : {}
ISBN : {}
출간일 : {}'''

print(result_text.format(search_text, result.find("lastBuildDate").text, result.find("display").text))
item_list = result.findall('item')

for x in range(len(item_list)):
    i = item_list[x]
    print("")
    print(item_text.format(x+1, i.find("title").text, i.find("author").text, i.find("price").text,
     i.find("publisher").text, i.find("isbn").text, i.find("pubdate").text,))
```

**OUTPUT**
```
검색어 : 9791132100997
검색 시간  : Fri, 16 Apr 2021 00:38:05 +0900
검색 결과 개수 : 1

검색 번호 : 1
책 제목 : 동역학 (공학도를 위한)
저자 : Ferdinand P. Beer
정가 : 37000
출판사 : 경문사
ISBN : 1132100992 <b>9791132100997</b>
```

지금과 같이 모든 item 태그에 접근하는 경우, **iterfind** 메소드를 사용하여 for문을 만들 수 도 있습니다! iterfind 메소드는 findall 메소드와 비슷한데, 리스트 대신 이터러블 객체를 반환한다는 점에서 차이가 있습니다.

## 정리

JSON과 XML형식의 데이터를 파싱하여 원하는 정보를 얻어내는 과정을 알아보았습니다. 정리하자면 다음과 같습니다.

**JSON**

1. json 모듈을 import한다.
2. json.loads 함수를 이용하여, json형식의 문자열을 파이썬 딕셔너리로 변환한다.
3. Document에 제시된 속성을 이용하여 데이터에 접근한다. (dict['key'])

**XML**

1. xml.etree.ElementTree 모듈을 import한다.
2. ElementTree.fromstring 함수를 이용하여, xml 형식의 문자열을 ElementTree로 변환한다. (함수가 반환하는 것은 Element)
3. Element 객체의 find, findall, iterfind 메소드 등을 이용하여, 각 태그 Element에 접근한다.
4. Element 객체의 text 속성을 이용하여, 태그에 담긴 정보를 읽는다.

또한, 검색 API는 검색 결과에서 검색어랑 완전히 일치하는 부분을 ```<b>``` 태그로 감쌉니다. 그래서 이를 제거 혹은 이용해야 합니다. 보통 이런 태그들을 **정규표현식**을 이용하여 제거하는 것 같습니다. 하지만 혹시 이 태그를 이용할 지 모르니, 실제로 제작하는 파트에서 제거하는 방법에 대한 짧은 설명을 추가하겠습니다!

# STEP 5 : What's next?

파이썬에 내장되어 있는 sqlite3 모듈에 대해 알아보고, 가능하다면 ORM(Object Relational Model)에 대해서도 알아보겠습니다!

그리고 Documents를 쭉 읽어보면서 두가지 궁금증이 생겼습니다.

1. **REST API**가 무엇인가?
2. **HTTP**는 어떻게 통신하는가?

이 두가지에 대해서는 여유가 있을 때 공부하고 포스트를 작성하겠습니다!

그리고 필요한 것들을 모두 조사한 뒤, 오늘 이해한 API 호출 방법을 기반으로 우리의 작품에 맞춰서 필요한 기능들을 제작해보겠습니다!

# 참고 자료

1. [NAVER API 공통 가이드](https://developers.naver.com/docs/common/openapiguide/)
2. [블로그 검색 API Document](https://developers.naver.com/docs/serviceapi/search/blog/blog.md#%EB%B8%94%EB%A1%9C%EA%B7%B8)
3. [책 검색 API Document](https://developers.naver.com/docs/serviceapi/search/book/book.md#%EC%B1%85)
4. [Python Document - urllib 모듈](https://docs.python.org/3/library/urllib.html)
5. [Python Document - json 모듈](https://docs.python.org/3/library/json.html)
6. [Python Document - ElemetTree 모듈](https://docs.python.org/ko/3/library/xml.etree.elementtree.html)